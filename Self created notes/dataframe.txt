------------- data types ------------------------------
There mainly 2 types of data types
    - numerical
        int64 - Basic python's int. It says that it uses 64 bits (8 bytes) to store int value.
        float64 - Basic python's float. It says that it uses 64 bits (8 bytes) to store double value.
    - character
        categorical - limited number of fixed values can be there in categorical column. This can save some memory for you.
        object - when number of values are not limited, object data type is used. whichever column has blank cell with NaN value, automatically gets object data type

dataTypes = cars_data.dtypes

    Price          int64
    Age          float64
    KM           float64
    FuelType      object
    HP            object
    MetColor     float64
    Automatic      int64
    CC             int64
    Doors         object
    Weight         int64

cols = cars_data.select_dtypes(include=[int])
return values of only int columns

cols = cars_data.select_dtypes(exclude=[object, int])
return values of non-int and non-object columns (only float columns)

summary =  cars_data.info()

     #   Column     Non-Null Count  Dtype
    ---  ------     --------------  -----
     0   Price      1436 non-null   int64
     1   Age        1336 non-null   float64
     2   KM         1421 non-null   float64
     3   FuelType   1336 non-null   object
     4   HP         1436 non-null   object

--------------------------------------------------------------
cars_data = pd.read_csv('Toyota.csv', index_col=0, na_values=['??', '###']) # replacing ?? and ### to NaN while loading the data from csv to dataframe.

row_ids = cars_data.index
get all index numbers (row ids)

columns = cars_data.columns
get all columns

size = cars_data.size
get total number of rows

shape = cars_data.shape
returns a tuple of (number of rows, number of columns)

memory = cars_data.memory_usage()
returns memory usage in bytes for every column

student = {
    'Name': ['John', 'Jay', 'sachin', 'Geetha', 'Amutha', 'ganesh'],
    'gender': ['male', 'male', 'male', 'female', 'female', 'male'],
    'math score': [50, 100, 70, 80, 75, 40],
    'test preparation': ['none', 'completed', 'none', 'completed',
                         'completed', 'none'],
}
df = pd.DataFrame(student)
creating dataframe from dictionary (map)


cars_data2 = cars_data.copy()
creating a copy of dataframe. Working on the copy, so that original data remains unchanged.

------------------- Filtering (head, tail, at, iat, loc, iloc, filtering through condition in df, where ----------------------------------
firstNRows = cars_data.head(15)
selecting the first 15 rows of dataframe. By default, it returns the first 5 rows.

lastNRows = cars_data.tail(15)
selecting the last 15 rows of dataframe. By default, it returns the last 5 rows.

result = cars_data.at[4, 'FuelType']
at[row id, column name] returns a cell data

result = cars_data.iat[4, 5]
iat[row id, column id] returns a cell data

df.loc takes two arguments, 'row index' and 'column index'
------

data.loc[(data.Brand == 'Maruti') & (data.Mileage > 25)]
selecting rows with all columns where Brand=Maruti and Mileage>25

data.loc[(data.Brand == 'Maruti') & (data.Mileage > 25), ['Mileage']]
selecting rows with only Mileage column where Brand=Maruti and Mileage>25

result = cars_data.loc[4:15, ['Price', 'FuelType']]
returns data of specific rows and columns

data.loc[(data.Year < 2015), ['Mileage']] = 22
change the values of Mileage column where year<2015

df.loc[df['First season'] > 1990, 'First Season'] = 1

df.iloc() function is an indexed-based selecting method
---------
data.iloc[[0, 2, 4, 7]]
selecting 0th, 2nd, 4th, and 7th index rows

data.iloc[1: 5, 2: 5]
selecting rows from 1 to 4 and columns from 2 to 4

filtered_data = dataframe[dataframe['Percentage'] > 80]
selecting rows based on condition. works same as loc() function.

filtered_data = np.where(dataframe['Percentage'] > 80,
                dataframe['Percentage'],
                np.nan)
if dataframe['Percentage'] > 80, then return dataframe['Percentage'], otherwise return NaN

--------------------nulls, not nulls summary------------------------------
summary =  cars_data.info()
returns the summary of dataframe

     #   Column     Non-Null Count  Dtype
    ---  ------     --------------  -----
     0   Price      1436 non-null   int64
     1   Age        1336 non-null   float64
     2   KM         1421 non-null   float64
     3   FuelType   1336 non-null   object
     4   HP         1430 non-null   float64

Price_Summary = cars_data['Price'].info()
returns the summary of a 'Price' column
    1436 non-null   int64

NaN_cells_in_each_column = cars_data.isnull().sum()   or   cars_data.isna().sum()
returns total null(NaN) cells in each column
    Price          0
    Age          100
    KM            15
    FuelType     100
    HP             6

--------------------- Data Clean Up (read_csv with nav_values, unique, replace, where, loc functions) ------------------------
cars_data = pd.read_csv(filepath_or_buffer = 'Toyota.csv', index_col=0, na_values=["??", "????"])
replacing ?? and ???? with NaN

doors_unique_elements = np.unique(cars_data['Doors'])
find unique values

cars_data.replace(to_replace='three', value=3, inplace=True)
cars_data.replace(to_replace='four', value=4, inplace=True)
cars_data.replace(to_replace='five', value=5, inplace=True)
replace values in entire dataframe(all columns)

cars_data["Doors"] = np.where(dataframe['Doors'] = 'three',
                3,
                dataframe['Doors'])
replacing data in a particular column


cars_data['Doors'] = cars_data['Doors'].astype(dtype='int64')
replacing datatype from object to int

cars_data.loc[df['Doors'] = 'three', 'Doors'] = 3

------------------ missing data (isnull, isna, isnull().any(axis=1), df[filters], describe(), fillna()-----------------

Either you can remove missing (NaN) data or replace them with proper value.
There are two ways to fill in the missing values.
    1. If it is a numerical column, then you can fill in mean/median
    2. If it's a categorical column, then you can fill in the max occurring category

NaN_cells_in_each_column = cars_data.isnull().sum()   or   cars_data.isna().sum()
returns total null(NaN) cells in each column
    Price          0
    Age          100
    KM            15
    FuelType     100
    HP             6


rows_with_missing_values = cars_data[cars_data.isnull().any(axis=1)]
selecting rows that have one or more missing values

rows_with_missing_age = cars_data[cars_data['Age'].isnull()]
find rows with missing (NaN) age.

filter1 = rows_with_missing_values['Age'].isnull()
filter2 = rows_with_missing_values['KM'].isnull()
rows_with_missing_age_and_km = cars_data[filter1 & filter2]
finding rows with missing age and km


print(cars_data.describe())
returns 5 pointer analysis

Average is represented by mean.
Median is represented by 50%

              Price          Age  ...  Age_Converted2  Km_per_month
count   1436.000000  1336.000000  ...     1336.000000   1321.000000
mean   10730.824513    55.672156  ...        4.639346      0.111520
std     3626.964585    18.589804  ...        1.549150      2.526162
min     4350.000000     1.000000  ...        0.083333      0.000177
25%     8450.000000    43.000000  ...        3.583333      0.000661
50%     9900.000000    60.000000  ...        5.000000      0.000880
75%    11950.000000    70.000000  ...        5.833333      0.001156
max    32500.000000    80.000000  ...        6.666667     76.000000

Filling up NaN Age with mean value
    mean_of_age = cars_data2['Age'].mean()
    print(mean_of_age) # 55.67215568862275
    cars_data2.fillna({'Age' : mean_of_age}, inplace=True)


Filling up NaN Age with median value
    median_of_km = cars_data2['KM'].median()
    print(median_of_km) # 63061.5
    cars_data2.fillna({'KM' : median_of_km}, inplace=True)

Filling up NaN MetColor with mode value
    In statistics, the mode is the value that is repeatedly occurring in a given set. We can also say that the value or number in a data set, which has a high frequency or appears more frequently, is called mode or modal value.

    mode_value_of_MetColor = cars_data2['MetColor'].mode()
    cars_data2.fillna({'MetColor': mode_value_of_MetColor[0]}, inplace=True)


For Categorical Data
--------------------

fuel_types_counts = cars_data2['FuelType'].value_counts(ascending=False)
    FuelType
    Petrol    1177
    Diesel     144
    CNG         15

indices = fuel_types_counts.index
cars_data2.fillna({'FuelType' : indices[0]}, inplace=True)
filling up NaN FuelType with 'Petrol'


------------------ Inserting a new column and filling up the data in it ------------------
# create new column in dataframe with default value as 0
cars_data.insert(10, "Age_Converted", 0)

def age_convert(val):
    val_converted = val/12
    return round(val_converted)

cars_data["Age_Converted"] = age_convert(cars_data["Age"])

print(age_converted_series.unique())

cars_data["Age_Converted"].fillna(0)

cars_data["Age_Converted"] = cars_data["Age_Converted"].astype(dtype="int64")


